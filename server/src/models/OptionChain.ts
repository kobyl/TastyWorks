// Generated by https://quicktype.io
const moment = require('moment-timezone');

export interface OptionChain {
    data: OptionWrapper;
    context: string;
}

export interface OptionWrapper {
    items: OptionData[];
}

export interface OptionData {
    "underlying-symbol": string;
    "root-symbol": string;
    "option-chain-type": string;
    "shares-per-contract": number;
    "tick-sizes": TickSize[];
    deliverables: Deliverable[];
    expirations: Expiration[];
}

export interface Deliverable {
    id: number;
    "root-symbol": string;
    "deliverable-type": string;
    description: string;
    amount: string;
    symbol: string;
    "instrument-type": string;
    percent: string;
}

export interface Expiration {
    "expiration-type": ExpirationType;
    "expiration-date": string;
    "days-to-expiration": number;
    "settlement-type": SettlementType;
    strikes: Strike[];
}

export enum ExpirationType {
    Regular = "Regular",
    Weekly = "Weekly",
}

export enum SettlementType {
    Pm = "PM",
}

export interface Strike {
    "strike-price": string;

    // Call and put symbols
    call: string;
    put: string;
    callDx: string;
    putDx: string;
}

export interface TickSize {
    value: string;
    threshold?: string;
}

const PATTERNS = {
    OCC_SYMBOL_PATTERN: /^([A-Z]{1,5})(\d?)([ ]{0,5})(\d{2})(\d{2})(\d{2})([CP])(\d{8})$/,
    OPTION_SYMBOL_PATTERN_OLD: /^([A-Z]+)(\d?)(\d{2})(\d{2})(\d{2})(\w)(.+)$/,
    OPTION_SYMBOL_PATTERN_NEW: /^([A-Z]+)(\d?)_(\d{2})(\d{2})(\d{2})(\w)(.+)$/,
    DX_OPTION_SYMBOL_PATTERN: /^\.([A-Z]+)(\d?)(\d{2})(\d{2})(\d{2})(\w)(.+)$/,
    DX_FUTURES_OPTION_SYMBOL_PATTERN: /^(\/[A-Z0-9]+)()_(\d{2})(\d{2})(\d{2})(\w)(.+)$/,
    TW_TWO_DIGIT_YEAR_FUTURES_OPTION_SYMBOL_PATTERN: /^\.\/([A-Z0-9]{2,4})([A-Z])([0-9]{2})[ ]([A-Z0-9]{2,4})([A-Z])([0-9]{2})[ ](\d{2})(\d{2})(\d{2})([CP])(\S+)$/,
    TW_ONE_DIGIT_YEAR_FUTURES_OPTION_SYMBOL_PATTERN: /^\.\/([A-Z0-9]{2,3})([A-Z])([0-9])[ ]{0,1}([A-Z0-9]{2,3})([A-Z])([0-9])[ ]{0,2}(\d{2})(\d{2})(\d{2})([CP])(\S+)$/
};


const EXPIRATION_OFFSETS = {
    SPX: {
        standard: -1,
        weekly: 0,
        quarterly: 0
    },
    SPXPM: {
        standard: 0
    },
    NDX: {
        standard: -1,
        weekly: -1
    },
    VIX: {
        standard: -1
    },
    VIXW: {
        standard: -1
    },
    RUT: {
        standard: -1,
        weekly: -1
    },
    DJX: {
        standard: -1,
        weekly: -1
    },
    MNX: {
        standard: -1,
        weekly: -1
    }
};

const TradeUtils = {
    OPEN_HOUR: 9.5,
    NEW_YORK_TZ: 'America/New_York',
    CLOSE_HOUR: 16,
    DEFAULT_OPTION_MULTIPLIER: 100,

    openingTimeForDateStrings: function (year, month, day) {
        return this.tradeTimeForDateStrings(year, month, day, TradeUtils.OPEN_HOUR);
    },
    tradeTimeForDateStrings: function (year, month, day, hour) {
        return TradeUtils._adjustDateTimeForHour(moment.tz(year + month + day, 'YYMMDD', TradeUtils.NEW_YORK_TZ), hour);
    },

    _adjustDateTimeForHour: function (datetime, hour) {
        var wholeHours, wholeMinutes;
        wholeHours = Math.floor(hour);
        wholeMinutes = (hour % 1) * 60;
        return datetime.hour(wholeHours).minutes(wholeMinutes).seconds(0).milliseconds(0);
    },

    closingTimeForDateStrings: function (year, month, day) {
        return this.tradeTimeForDateStrings(year, month, day, TradeUtils.CLOSE_HOUR);
    },
};

const isAmSettled = function (rootSymbol) {
    var offset;
    offset = EXPIRATION_OFFSETS[rootSymbol];
    return offset && offset['standard'] < 0;
}

const STANDARD = 'standard';
const MINI_FLAGS = ['7', '8', '9'];
const __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

const  MARKET_HOLIDAYS = {
    "2014-07-04": "Independence Day 2014",
    "2015-03-29": "Good Friday 2015",
    "2015-07-03": "Independence Day 2015",
    "2015-12-25": "Christmas Day 2015",
    "2016-01-01": "New Years Day 2016",
    "2016-03-25": "Good Friday 2016",
    "2017-04-14": "Good Friday 2017",
    "2018-03-30": "Good Friday 2018"
  };



const  SECOND = 1000;
const  MINUTE = 60 * SECOND;
const  HOUR = 60 * MINUTE;
const  DAY = 24 * HOUR;

const getExpirationDateAdjustedForHolidays = function (expirationDate) {
    var date;
    date = expirationDate.format('YYYY-MM-DD');
    if (MARKET_HOLIDAYS[date] || expirationDate.day() === 6) {
        expirationDate = expirationDate.clone();
        expirationDate.subtract(1, 'days');
    }
    return expirationDate;
};
const getDaysToExpirationWithType = function (expirationDate, _arg) {
    var adjustedExpirationDate, days, daysFraction, daysToExpiration, diff, settlementType, startDate, symbol;
    startDate = _arg.startDate, symbol = _arg.symbol, settlementType = _arg.settlementType;
    if (startDate == null) {
        startDate = new Date();
    }
    adjustedExpirationDate = getExpirationDateAdjustedForHolidays(expirationDate);
    daysFraction = (adjustedExpirationDate - startDate) / DAY;
    if (daysFraction < 0) {
        return NaN;
    }
    days = Math.floor(daysFraction);
    diff = daysFraction - days;
    daysToExpiration = diff > 0.6 ? days + 1 : days;
    if (settlementType === 'AM') {
        if (daysToExpiration < 1) {
            return 0;
        }
        return daysToExpiration - 1;
    }
    return daysToExpiration;
}

// Generated by https://quicktype.io

export interface OptionSymbol {
    underlyingSymbol:       string;
    expirationDate:         string;
    daysToExpiration:       number;
    callOrPut:              string;
    strikePrice:            number;
    realTradingSymbol:      string;
    optionChainType:        string;
    rawOptionChainType:     string;
    multiplier:             number;
    dateRaw:                string;
    strikePriceRaw:         string;
    rootSymbol:             string;
    expirationKey:          string;
    futureOptionRootSymbol: null;
}

export const getDxSymbol = function(meta : OptionSymbol) {
    const rootSymbol = meta.rootSymbol || meta.underlyingSymbol;
    return "." + rootSymbol + meta.rawOptionChainType + meta.dateRaw + meta.callOrPut + meta.strikePrice;
}

export const optionSymbolToObject:(s: string) => OptionSymbol = function (symbol: string) {
    var callOrPut, dateRaw, day, daysToExpiration, e, expirationDate, expirationKey, futureOptionRootSymbol, miniFlag, month, multiplier, nonStandard, optionChainType, rawOptionChainType, realTradingSymbol, res, rootSymbol, settlementType, strikePrice, strikePriceRaw, underlyingSymbol, year;
    try {
        futureOptionRootSymbol = null;
        if ((res = symbol.match(PATTERNS.OCC_SYMBOL_PATTERN))) {
            year = res[4];
            month = res[5];
            day = res[6];
            callOrPut = res[7];
            strikePriceRaw = res[8];
            strikePrice = parseFloat(strikePriceRaw) / 1000.0;
            realTradingSymbol = symbol;
        } else if (symbol.indexOf('./') === 0 && symbol.length > 20) {
            if ((res = symbol.match(PATTERNS.TW_TWO_DIGIT_YEAR_FUTURES_OPTION_SYMBOL_PATTERN))) {
                underlyingSymbol = '/' + res[1] + res[2] + res[3];
                futureOptionRootSymbol = res[4] + res[5] + res[6];
                year = res[7];
                month = res[8];
                day = res[9];
                callOrPut = res[10];
                strikePriceRaw = res[11];
                strikePrice = parseFloat(strikePriceRaw);
                realTradingSymbol = symbol;
                rootSymbol = underlyingSymbol + ' ' + futureOptionRootSymbol + ' ';
            } else if ((res = symbol.match(PATTERNS.TW_ONE_DIGIT_YEAR_FUTURES_OPTION_SYMBOL_PATTERN))) {
                underlyingSymbol = '/' + res[1] + res[2] + res[3];
                futureOptionRootSymbol = res[4] + res[5] + res[6];
                year = res[7];
                month = res[8];
                day = res[9];
                callOrPut = res[10];
                strikePriceRaw = res[11];
                strikePrice = parseFloat(strikePriceRaw);
                realTradingSymbol = symbol;
                rootSymbol = symbol.substring(0, 13);
            } else {
                throw new Error('Invalid future option symbol');
            }
        } else if (symbol.indexOf('/') === 0) {
            res = symbol.match(PATTERNS.DX_FUTURES_OPTION_SYMBOL_PATTERN);
            month = res[3];
            day = res[4];
            year = res[5];
            callOrPut = res[6];
            strikePriceRaw = res[7];
            strikePrice = parseFloat(strikePriceRaw);
            realTradingSymbol = symbol;
        } else if (symbol.indexOf('_') > -1) {
            res = symbol.match(PATTERNS.OPTION_SYMBOL_PATTERN_NEW);
            month = res[3];
            day = res[4];
            year = res[5];
            callOrPut = res[6];
            strikePriceRaw = res[7];
            strikePrice = parseFloat(strikePriceRaw);
            realTradingSymbol = symbol;
        } else if (symbol[0] === '.') {
            res = symbol.match(PATTERNS.DX_OPTION_SYMBOL_PATTERN);
            year = res[3];
            month = res[4];
            day = res[5];
            callOrPut = res[6];
            strikePriceRaw = res[7];
            strikePrice = parseFloat(strikePriceRaw);
            realTradingSymbol = symbol;
        } else {
            res = symbol.match(PATTERNS.OPTION_SYMBOL_PATTERN_OLD);
            year = res[3];
            month = res[4];
            day = res[5];
            callOrPut = res[6];
            strikePriceRaw = res[7];
            strikePrice = parseFloat(strikePriceRaw);
            realTradingSymbol = "" + res[1] + res[2] + "_" + (res[4] + res[5] + res[3] + res[6] + res[7]);
        }
    } catch (_error) {
        e = _error;
        //   if (typeof Raven !== "undefined" && Raven !== null) {
        //     Raven.captureException(e, {
        //       tags: {
        //         context: "SymbolUtils.optionSymbolToObject while trying to parse symbol: " + symbol
        //       }
        //     });
        //   }
        throw e;
    }
    if (!underlyingSymbol) {
        underlyingSymbol = res[1];
    }
    if (!rootSymbol) {
        rootSymbol = underlyingSymbol;
    }
    if (underlyingSymbol === 'SPXW' || underlyingSymbol === 'SPXQ') {
        underlyingSymbol = 'SPX';
    }
    if (underlyingSymbol === 'VIXW') {
        underlyingSymbol = 'VIX';
    }
    if (underlyingSymbol === 'RUTQ' || underlyingSymbol === 'RUTW') {
        underlyingSymbol = 'RUT';
    }
    if (underlyingSymbol === 'NDXP') {
        underlyingSymbol = 'NDX';
    }
    if (isAmSettled(rootSymbol)) {
        expirationDate = TradeUtils.openingTimeForDateStrings(year, month, day); //, expirationDate);
        settlementType = 'AM';
    } else {
        expirationDate = TradeUtils.closingTimeForDateStrings(year, month, day); //, expirationDate);
        settlementType = 'PM';
    }
    optionChainType = STANDARD;
    if (futureOptionRootSymbol === null) {
        expirationKey = "20" + year + "-" + month + "-" + day + " " + settlementType;
        rawOptionChainType = nonStandard = res[2];
        multiplier = TradeUtils.DEFAULT_OPTION_MULTIPLIER;
        if (nonStandard) {
            if (__indexOf.call(MINI_FLAGS, nonStandard) >= 0) {
                multiplier = 10;
                optionChainType = 'mini' + nonStandard;
            } else {
                optionChainType = 'ns' + nonStandard;
            }
            miniFlag = nonStandard;
        }
    } else {
        expirationKey = "20" + year + "-" + month + "-" + day + " " + futureOptionRootSymbol;
        multiplier = 1;
    }
    daysToExpiration = getDaysToExpirationWithType(expirationDate, {
        symbol: rootSymbol,
        settlementType: settlementType
    });
    dateRaw = "" + year + month + day;
    return {
        underlyingSymbol: underlyingSymbol,
        expirationDate: expirationDate,
        daysToExpiration: daysToExpiration,
        callOrPut: callOrPut,
        strikePrice: strikePrice,
        realTradingSymbol: realTradingSymbol,
        optionChainType: optionChainType,
        miniFlag: miniFlag,
        rawOptionChainType: rawOptionChainType,
        multiplier: multiplier,
        dateRaw: dateRaw,
        strikePriceRaw: strikePriceRaw,
        rootSymbol: rootSymbol,
        expirationKey: expirationKey,
        futureOptionRootSymbol: futureOptionRootSymbol
    };
}